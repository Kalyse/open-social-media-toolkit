<?php


/*
 * 
 * 

The dbRowObject class is a dynamic container for single rows fetched from MySQL tables. The design goal 
was to eliminate the need to hand-write container objects and queries for rows of different tables
, thus improving code readability and maintainability and eliminating a major category of difficult to 
catch errors.
  
The dbRowObject exposes to the user methods to load, insert, update, and delete a row from the database, 
as well as direct access to the columns via field variables. 
  
The intended use pattern is as follows:

//-------------------------


// turn on debug of all dbRowObject operations if desired
dbRowObject::$debug = 1;

// instantiate or have cached a table object
$userTable = new UserTable($this->db);

// ask the table for an empty row object customized to access user records
$user = $userTable->getRowObject();  

// populate the row object by fetching a user record from the database with userid=100

if (!$user->load(100)) 
{
	// load returns false if the record didnt exist, so we should always check the return
	die("Couldnt find user 100!");
}


// now the members of $user are automagically populated with the columns of the user record

echo $user->name; // contents of column labeled 'name'
echo $user->ncUid; // .. 'ncUid'
echo $user->isMember; // .. 'isMember'

// we can now change the members at will
$user->name = 'Bob Barr';

// but the database isnt updated until well call update()!

$user->update(); // now user record 100's name is 'Bob Barr'. note that update overwrites all columns in the table with the contents of $user

// updating the id field will change which record update() affects!

$user->userid = 101;
$user->name= 'Alan Keyes';
$user->update(); // all of record 101's fields are now updated with current contents of $user, in particular the name is now 'Alan Keys'


// inserting a record is similar to setting up the fields, but the id field is ignored - the primary key is ASSUMED to be auto_increment

$user->userid = 23425;
$user->name = 'A New User';

$newId = $user->insert(); // inserts a new row in the table with all the members populated as one would expect, except a new id is generated by the DB, set on the object, and returned. 

// $user->userid == $newId
// $newId != 23425

  
// insert can also be used with an id specified AS A PARAMETER to force insertion of a row with specified id

$newId = $user->insert(999);

// $newId == 999 == $user->userid 



// finally, delete removes the row with the corresponding id

$user->delete(); // user 999 deleted



// load($id, 'idname') can also be used to load based on a secondary key
// this is actually encapsulated by the UserInfoRow class, which derives from dbRowObject but implements a helper method:


class UserInfo extends dbRowObject 
{

  function loadFromFbId($fbId)
  {
  	return $this->load($fbId, 'fbId');
  }

  // ... other stuff
}

// an extra helper function loadWhere can be used to provide general conditions for loading, for example if there is unique condition we might want to use:


class UserInviteRow extends dbRowObject  
{
	function loadFromFbIdAndUserid($fbId, $userid)
	{
		return $this->loadWhere("friendFbId=$fbId AND userid=$userid");
	}
	
}


//----------------------
How it works

dbRowObject uses the magic __get and __set methods to lookup 
requested field names against a list of column names passed in by the table class. load, update, 
insert, and delete dynamically build the correct query strings to fetch, update, and create rows 
in the table from the list of field names and the values of the object members. Everything unique 
to a table in concisely described in the Table class and static references are passed in to 
the dbRowObject's constructor to configure it with the table name and field names.


*/


class dbRowObject
{
	//var $id = 0;
	protected $idname = 'id'; // default name of primary key/id
	protected $table;
	protected $fields; // wont currently contain a shallow copy of the table field list, but should 
	protected $nonidfields; // just lists all fields except the primary key
	var $db;
	static $debug = 0;
	function __construct( $db, $table, $fields, $idname='id' )
  	{
  
  		if (is_null($db)) 
  		{  
			die("DBObject requires a valid db object"); // refuse to make new connections for each db access object   
		} else
			$this->db=$db;
			
		$this->table = $table;
	    foreach( $fields as $key )
	    {
	    	$this->fields[ $key ] = null;
	    }
	    		
		// new		
		$this->idname = $idname;
		
	    $this->nonidfields = $fields; // use this copy of field list for db ops
	    $this->fields[$this->idname] = null; // so id field can be set/get correctly
		
  	}
  	
  	function filterFieldFromInsertAndUpdate($timestampfieldname) // call this in your own constructor to filter these fields if they might exist. potentially slow, so not called by default
  	{
  		foreach ($this->nonidfields as $key => $f)
  		{	
  			if (0==strcasecmp($f,$timestampfieldname))
  			{
  				unset($this->nonidfields[$key]);
  			}
  		}
  	}
  	
  	function __get( $key )
  	{
	    return $this->fields[ $key ];
  	}

  	function __set( $key, $value )
  	{	
    	if ( array_key_exists( $key, $this->fields ) )
    	{
      		$this->fields[ $key ] = $value;
      		return true;
    	}
    	return false;
  	}

 	/*
 	 * 
 	 * Inserts a new record in to the database, and sets $this->{$idname} to the returned id
  	 * 
  	 * 
  	 */  
	function insert($set_id=NULL)
	{
    	$fields .= join( ", ", $this->nonidfields ); 
    	//join( ", ", array_keys( $this->fields ) );
	
		//echo '$fields ='.$fields."\n";

		$values = array();
    	foreach( /*array_keys( $this->fields )*/$this->nonidfields as $field )
    	{
    		$value = mysql_real_escape_string(stripslashes($this->fields[ $field ]));
    		$values []= "'{$value}'";  		    		
    	}
		$valuestring = join(', ', $values);
		
		if ($set_id!=NULL) // specifying a specific id
		{
			$fields .= ', '.$this->idname;
			$valuestring .= ', '.$set_id;
		}
		
		if (dbRowObject::$debug) echo "\n<BR>insert string: (\"$this->table\", \"$fields\", \"$valuestring\")<BR>\n";
					

		$newId=$this->db->insert($this->table,$fields, $valuestring);
			
		if ($set_id != NULL && is_numeric($newId)) // set_id usually used with non-autoincrement id columns, so $newId will always be zero
			$newId = $set_id;
			
		$this->{$this->idname} = $newId;
		//$idname = $this->idname;
		//echo "--{$this->idname} -- " . $this->{$idname} . " = " . $newId . "-------";
		return $newId;	
		
	}
	/*
	 * Updates a record based on $id, using current values of all fields
	 * Assumes $id is valid  
	 */
	function update()
	{
   	
		$updatestring = '';
		foreach( /*array_keys( $this->fields )*/$this->nonidfields as $field )
    	{
    		$value = mysql_real_escape_string(stripslashes($this->fields[ $field ]));
    		$updatestring .= "$field='$value',";
    	}
		$updatestring = rtrim($updatestring, ',');
		
    	$wherestring = $this->idname. '='.$this->{$this->idname}; //"{$this->{$idname}=$this->id";

    	
    	if (dbRowObject::$debug) echo "<br>updatestring: ($this->table, $updatestring, $wherestring)<br>";
		$this_query=$this->db->update($this->table,$updatestring,$wherestring);

		// TODO: maybe have some status checking here? 
	}
	
	/*
	 * Loads contents of row at specified id into the object, returns the id if successful and false otherwise 
	 * 
	 */
	
	function load($id=0, $idname=NULL) // option to override idname useful when cross-referencing tables with multiple unique id keys
	{
		//echo "<p>id: $id</p>";
		$idname = !$idname ? $this->idname : $idname;
		if (dbRowObject::$debug) echo "<p>SELECT * FROM {$this->table} WHERE {$idname}=$id</p>";
		$res=$this->db->query("SELECT * FROM {$this->table} WHERE {$idname}=$id");
		
		//print_r($res);
			
		//if ($res!==false) {
		if ($this->db->countQ($res)) 
		{
			$row=$this->db->readQ($res);
		} else 
			return false;	

		//echo 'dbRowObject::load: ' .print_r($row,true);
			
		//$this->{$this->idname} = $id; // obsolete
		foreach( array_keys( (get_object_vars($row))) as $key )
      		$this->fields[ $key ] = $row->{"$key"};
			
		return $id;
	}
	
	function loadWhere($wherestring) // lower level, more general load op can use arbitrary conditions
	{
		
		if (dbRowObject::$debug) echo "<p>SELECT * FROM {$this->table} WHERE $wherestring</p>";
		$res=$this->db->query("SELECT * FROM {$this->table} WHERE $wherestring");
		
		if ($this->db->countQ($res)) 
		{
			$row=$this->db->readQ($res);
		} else 
			return false;	

		foreach( array_keys( (get_object_vars($row))) as $key )
      		$this->fields[ $key ] = $row->{"$key"};
			
		return $this->{$this->idname};
	}
	
	function delete() 
	{
		//echo "This->{$this->idname} = {$this->{$this->idname}})\n";
		//echo "{$this->idname}={$this->id}\n";
	
	 	$this->db->delete($this->table,"{$this->idname}={$this->{$this->idname}}");
		
	}
	
	
	function debugPrint()
	{
		
		$code .= '<p>[<br>';
		foreach( array_keys( $this->fields ) as $field )
    	{
    		$code .= $field .' => '.$this->fields[$field].'<br>';
    	}
   	
		$code .= ']</p>';
		return $code;
	}
}


?>
